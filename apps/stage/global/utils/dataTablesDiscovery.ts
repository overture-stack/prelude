// global/utils/dataTablesDiscovery.ts
import fs from 'fs';
import path from 'path';
import { getTableConfig } from './tableConfig';

export interface DataTableInfo {
	id: string;
	title: string;
	path: string;
}

/**
 * Discovers data tables by scanning the pages directory for dataTable* folders.
 *
 * Updated for new architecture:
 * - Now scans pages/ directory instead of components/pages/activeDataTables
 * - Looks for folders matching pattern: dataTable*
 * - Works with the refactored structure where config lives in pages/
 *
 * Learning Note: File System Operations in Next.js API Routes
 * - fs module only works server-side (Node.js)
 * - process.cwd() gives the root directory of the project
 * - path.join() safely creates cross-platform file paths
 */
export function discoverDataTables(): DataTableInfo[] {
	try {
		/**
		 * Updated path: Now points to pages/ directory
		 * This matches our new architecture where data table pages live in pages/dataTable*
		 */
		const pagesPath = path.join(process.cwd(), 'pages');

		// Check if directory exists
		if (!fs.existsSync(pagesPath)) {
			console.warn('Pages directory not found:', pagesPath);
			return [];
		}

		/**
		 * Read all entries in pages directory
		 * withFileTypes: true gives us Dirent objects (includes isDirectory() method)
		 */
		const entries = fs.readdirSync(pagesPath, { withFileTypes: true });

		/**
		 * Filter for directories that match our data table naming pattern
		 *
		 * Pattern: *Table (e.g., correlationTable, mutationTable, expressionTable, proteinTable)
		 * Also supports legacy dataTable* pattern for backwards compatibility
		 * - Must be a directory
		 * - Must end with "Table" OR start with "dataTable"
		 *
		 * This automatically discovers all data tables without hardcoding them!
		 */
		const dataTableDirs = entries.filter(
			(entry) => entry.isDirectory() && (entry.name.endsWith('Table') || entry.name.startsWith('dataTable')),
		);

		/**
		 * Convert directory names to DataTableInfo objects
		 *
		 * Priority order for table names:
		 * 1. Environment variable (e.g., NEXT_PUBLIC_CORRELATION_TABLE_NAME)
		 * 2. tableConfig.ts configuration
		 * 3. Auto-generated from folder name
		 */
		return dataTableDirs.map((dir) => {
			/**
			 * Check for environment variable override
			 * Format: NEXT_PUBLIC_CORRELATION_TABLE_NAME for correlationTable
			 * Legacy format: NEXT_PUBLIC_DATATABLE_ONE_NAME for dataTableOne
			 */
			const envKeyBase = dir.name
				.replace(/([A-Z])/g, '_$1') // correlationTable → correlation_Table
				.toUpperCase() // CORRELATION_TABLE
				.replace(/^_/, ''); // Remove leading underscore if present

			const envDisplayName = process.env[`NEXT_PUBLIC_${envKeyBase}_NAME`];

			/**
			 * Check for custom configuration from tableConfig.ts
			 */
			const customConfig = getTableConfig(dir.name);

			/**
			 * Auto-generate title as fallback
			 *
			 * Example: "dataTableOne" → "Data Table One"
			 */
			const autoGeneratedTitle = dir.name
				.replace(/([A-Z])/g, ' $1') // Add space before capitals
				.replace(/^./, (str) => str.toUpperCase()) // Capitalize first letter
				.trim();

			/**
			 * Create the URL path
			 * Next.js automatically maps pages/dataTableOne/index.tsx to /dataTableOne
			 */
			const urlPath = `/${dir.name}`;

			return {
				id: dir.name, // e.g., "dataTableOne"
				title: envDisplayName || customConfig?.displayName || autoGeneratedTitle, // Env > Config > Auto
				path: urlPath, // e.g., "/dataTableOne"
			};
		});
	} catch (error) {
		console.error('Error discovering data tables:', error);
		return [];
	}
}
